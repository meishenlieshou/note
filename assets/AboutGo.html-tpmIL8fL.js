import{_ as t,c as e,a as l,o as p}from"./app-Okfm5--O.js";const a={};function i(n,o){return p(),e("div",null,o[0]||(o[0]=[l('<p>Go 入门</p><ol><li>Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？</li></ol><p>传统C/C++链接/编译时间长，对新的硬件特性如分布式、多核、云计算等支持优化不充分，由此创建Go</p><ol start="2"><li>Go的主要特点是什么？有什么重要功能？</li></ol><p>Go的编译过程很快，二进制程序包又比较小，并发性好</p><ol start="3"><li>为什么Go编译器能达到那么快的编译速度呢</li></ol><p>它之所以快，有两个原因。首先Go有两个编译器——两个单独的实现。一个是按照Plan 9（http://plan9.bell-labs.com/wiki/plan9/1/） 风格新写的编译器。一个编译器叫做GCC Go。</p><p>Plan 9风格编译器的速度是GCC Go的5倍，因为它从头到脚都是全新的，没有GCC后端，那些东西会花很多时间来产生真正的好代码。</p><p>Go速度快的根源主要归功于对依赖的管理。</p><ol start="4"><li>Go里的类型系统</li></ol><p>在Go里<strong>没有类的概念</strong>，取而代之的是结构，以及为此结构声明的一些方法。</p><p>结构不能与类混为一谈。但是你也可以把方法放在数组、整数、浮点数或字符串上，实际上任何类型都可以有方法。</p><p>Go只允许你在包内为你所实现的类型定义方法。我不能引入你的类型然后直接把我的方法增加进去</p><p>例如你不能直接给int增加方法。因为整数类型不是你定义的，不在你的包里，它是引入的但并不在你的包中定义，这就意味着你不能给其增加方法。你不能给不在你包里定义的类型增加方法。</p><ol start="5"><li><p>我们从底层说起吧，在Go里最小的类型是: bool、int和float，然后是int32、float64之类有尺寸的类型、字符串、复杂类型</p></li><li><p>指针</p></li></ol><p>在Go里，任何类型都是值类型，和C一样，所有东西都是按值调用，但是你也可以用指针。如果你想引用某样东西，可以获取其地址，这样你就有了一个指针。Go也有指针但是比C指针有更多限制，Go里的指针是安全的，因为他们是类型安全的，所以你没法欺骗编译器，而且也没有指针运算，因此，如果你有个指向某物的指针，你无法将其移到对象外，也无法欺骗编译器。</p><ol start="7"><li>接口</li></ol><p>Go里的接口真的非常、非常地简单。接口指明了两个不同事情：其一，它表明了类型的构思，接口类型是一个罗列了一组方法的类型，因此如果你要抽象一组方法来定义一个行为，那么就定义一个接口并声明这些方法。现在你就有了一个类型，我们就叫它接口类型吧，那么从现在起所有实现了接口中这些方法的类型——包括基本类型、结构、映射（map）或其它什么类型，都隐含符合该接口要求。其二，也是真正有意思的是，和大多数语言中的接口不同的是，Go里面没有“implements”声明。</p><p>你无须说明“我的对象实现了这个接口”，只要你定义了接口中的那些方法，它就自动实现了该接口。有些人对此感到非常担忧，依我看他们想说的是：知道自己实现（Implement）了什么接口真的很重要。如果你真想确定自己实现了什么接口，还是有技巧可以做到这一点的。但是我们的想法与此截然不同，我们的想法是你不应该考虑实现什么接口，而是应该写下要做的东西，因为你不必事前就决定要实现哪个接口。可能后来你实际上实现了某个现在你尚不知晓的接口，因为该接口还未设计出来，但是现在你已经在实现它。</p><p>后来你可能发现两个原先未曾考虑过相关性的类具有了相关性——我又用了类这个词，我思考Java太多了——两个structs都实现了一些非常有用的小子集中的相关方法，这时有办法能够操作这两个structs中的任意一个就显得非常有用了。这样你就可以声明一个接口，然后什么都不用管了，即使这些方法是在别人的代码中实现的也没问题，虽然你不能编辑这些代码。如果是Java，这些代码必须要声明实现你的接口，在某种意义上，实现是单向的。然而在Go里，实现是双向的。对于接口实际上有不少漂亮而简单的例子。</p><ol start="8"><li>鸭子类型系统</li></ol><p>不考虑它的行为的话，它是有点像结构化类型系统。不过它是完全抽象的，其意并不在拥有什么，而是能做什么。有了结构（struct）之后，就规定了其内存的样子，然后方法说明了结构的行为，再之后，接口则抽象了该结构及其它实现了相同方法的其他结构中的这些方法。这是一种鸭子类型系统（duck typing，一种动态类型系统，http://en.wikipedia.org/wiki/Duck_typing），而不是结构化类型系统。</p>',22)]))}const G=t(a,[["render",i]]),s=JSON.parse('{"path":"/notes/learn/fullstack/AboutGo.html","title":"","lang":"en-US","frontmatter":{"description":"Go 入门 Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？ 传统C/C++链接/编译时间长，对新的硬件特性如分布式、多核、云计算等支持优化不充分，由此创建Go Go的主要特点是什么？有什么重要功能？ Go的编译过程很快，二进制程序包又比较小，并发性好 为什么Go编译器能达到那么快的编译速...","head":[["meta",{"property":"og:url","content":"https://duduainy.top/notes/learn/fullstack/AboutGo.html"}],["meta",{"property":"og:site_name","content":"Seasoned Jack"}],["meta",{"property":"og:description","content":"Go 入门 Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？ 传统C/C++链接/编译时间长，对新的硬件特性如分布式、多核、云计算等支持优化不充分，由此创建Go Go的主要特点是什么？有什么重要功能？ Go的编译过程很快，二进制程序包又比较小，并发性好 为什么Go编译器能达到那么快的编译速..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-07-01T13:47:35.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-01T13:47:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-01T13:47:35.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.69,"words":1406},"git":{"updatedTime":1751377655000},"autoDesc":true,"filePathRelative":"notes/learn/fullstack/AboutGo.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"18b1a2","sort":10001,"name":"learn"},{"id":"148e22","sort":10002,"name":"fullstack"}],"bulletin":false}');export{G as comp,s as data};
